From bde45e2f168597c8f4b2bb0599d58125fd24deb6 Mon Sep 17 00:00:00 2001
From: Holger Hans Peter Freyther <zecke@selfish.org>
Date: Wed, 13 Jun 2012 11:17:33 +0200
Subject: [PATCH] cell_log: Use the RF-Lock handling to unlock the GSM network

This is missing the reason of why and when something is unlocked.
---
 src/util/cell_log.c |   65 ++++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 54 insertions(+), 11 deletions(-)

diff --git a/src/util/cell_log.c b/src/util/cell_log.c
index 59d8942..7a280aa 100644
--- a/src/util/cell_log.c
+++ b/src/util/cell_log.c
@@ -27,10 +27,14 @@
 #include <fcntl.h>
 #include <time.h>
 #include <syslog.h>
+#include <stdint.h>
 
 #include <sys/types.h>
+#include <sys/socket.h>
 #include <sys/stat.h>
 
+#include <netinet/in.h>
+
 #include <libgsmd/libgsmd.h>
 #include <libgsmd/voicecall.h>
 #include <libgsmd/misc.h>
@@ -58,31 +62,70 @@ static int pending_responses = 0;
 #define MIN_NO_NET_SECS	60
 #define OUR_MCC 901
 #define OUR_MNC 99
-#define LOCK_PATH "/var/lock/bts_rf_lock"
 
 static time_t last_network_seen;
 unsigned int rf_lock_active = 0;
 
 static void bts_rf_lock(int on)
 {
-	int fd;
+	int fd, rc;
+
+	static const uint8_t rf_lock[] = {
+		0x00, 0x23, 0xEE, 0x00, 0x53, 0x45, 0x54, 0x20,
+		0x31, 0x20, 0x6E, 0x65, 0x74, 0x2E, 0x72, 0x66,
+		0x5F, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x67, 0x73,
+		0x6D, 0x2C, 0x6C, 0x6F, 0x63, 0x6B, 0x2C, 0x6E,
+		0x2F, 0x61, 0x2C, 0x6E, 0x2F, 0x61,
+	};
+
+	static const uint8_t rf_unlock[] = {
+		0x00, 0x25, 0xEE, 0x00, 0x53, 0x45, 0x54, 0x20,
+		0x31, 0x20, 0x6E, 0x65, 0x74, 0x2E, 0x72, 0x66,
+		0x5F, 0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x67, 0x73,
+		0x6D, 0x2C, 0x75, 0x6E, 0x6C, 0x6F, 0x63, 0x6B,
+		0x2C, 0x6E, 0x2F, 0x61, 0x2C, 0x6E, 0x2F, 0x61,
+	};
 
 	/* only print message on status change */
 	if (rf_lock_active != on)
 		syslog(LOG_NOTICE, "RF_LOCK: %sabling lock\n", on ? "En" : "Dis");
 
-	/* for safety, always update the actual file on disk */
+	fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (fd == -1) {
+		syslog(LOG_ERR, "RF_LOCK: socket creation failed: %d\n", errno);
+		return;
+	}
+
+	struct sockaddr_in addr;
+	memset(&addr, 0, sizeof(addr));
+	addr.sin_family = AF_INET;
+	addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+	addr.sin_port = htons(4249);
+	rc = connect(fd, (struct sockaddr *) &addr, sizeof(addr));
+	if (rc != 0) {
+		syslog(LOG_ERR, "RF_Lock: socket connect failed: %d\n", errno);
+		close(fd);
+		return;
+	}
+
 	if (on == 1) {
-		struct stat st;
-		if (stat(LOCK_PATH, &st) != 0) {
-			fd = open(LOCK_PATH, O_WRONLY|O_CREAT, 0664);
-			if (fd >= 0)
-				close(fd);
-		}
-	} else
-		unlink(LOCK_PATH);
+		rc = write(fd, rf_lock, sizeof(rf_lock));
+		if (rc != sizeof(rf_lock))
+			goto error;
+	} else {
+		rc = write(fd, rf_unlock, sizeof(rf_unlock));
+		if (rc != sizeof(rf_unlock))
+			goto error;
+	}
 
+	close(fd);
 	rf_lock_active = on;
+	return;
+
+error:
+	close(fd);
+	syslog(LOG_ERR, "RF_Lock: failed to send the message: %d\n", errno);
+	return;
 }
 
 
-- 
1.7.10.4

